// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// ------------------------------------------------------------------------------------------------- module
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --                                                                                                    --
// --                                                                                                    --
// --             "esp8266_test"                                                                         --
// --                                                                                                    --
// --                                                                                                    --
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// ---------------------------------------------------------------------------------------------- component
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --                                                                                                    --
// --                                                                                                    --
// -- title       : esp8266_test                                                                         --
// -- version     : 2.0                                                                                  --
// -- framework   : arduino                                                                              --
// -- author      : goldobin a.                                                                          --
// -- company     : cardboard.ru                                                                         --
// -- data        : 08/09/2022                                                                           --
// --                                                                                                    --
// --                                                                                                    --
// -- description :                                                                                      --
// --                                                                                                    --
// --                                                                                                    --
// --             (1) осуществляется ОДНОВРЕМЕННОЕ выполнение трёх потоков задач                         --
// --                 каждому потоку задач соответствует отдельный ПРОЦЕСС                               --
// --                                                                                                    --
// --                 BL (blink)    - непрерывная световая сигнализация                                  --
// --                 KP (keypress) - контроль нажатия встроенной кнопки                                 --
// --                 TS (timescan) - периодический вывод в UART значения времени                        --
// --                                                                                                    --
// --             (2) BL (blink) - это ПРОЦЕСС непрерывной световой сигнализации.                        --
// --                 для сигнализации используется единственный встроенный светодиод LED_BUILTIN.       --
// --                 бесконечно исполняемый цикл описывается таблицей                                   --
// --                                                                                                    --
// --                 Задача       Интервал        LED_BUILTIN                                           --
// --                 BL01         20 мс           HIGH                                                  --
// --                 BL02         300 мс          LOW                                                   --
// --                 BL03         20 мс           HIGH                                                  --
// --                 BL04         300 мс          LOW                                                   --
// --                 BL05         500 мс          HIGH                                                  --
// --                 BL06         500 мс          LOW                                                   --
// --                 BL07         500 мс          HIGH                                                  --
// --                 BL08         500 мс          LOW                                                   --
// --                                                                                                    --
// --             (3) задача BL00 исполняются однократно.                                                --
// --                 поток задач BL01 .. BL08 исполняются непрерывно.                                   --
// --                                                                                                    --
// --             (4) TS (timescan) - это ПРОЦЕСС периодического вывода в UART значения времени.         --
// --                 Клиент UDP/NTP. Считывание значения времени на сервере по протоколу NTP.           --
// --                 Обмен осуществляется с помощью сетевых пакетов UDP.                                --
// --                 Подробная справка о серверах времени NTP и необходимом формате сообщений           --
// --                 http://en.wikipedia.org/wiki/Network_Time_Protocol                                 --
// --                                                                                                    --
// --             (5) поток задач TS00 .. TS05 исполняются однократно.                                   --
// --                 поток задач TS06 .. TS19 исполняются непрерывно. через каждые 3 сек                --
// --                 выполняется алгоритм                                                               --
// --                                                                                                    --
// --
// -- (TS00, TS01, TS02, TS03, TS04, TS05) -> TS06, TS07, TS08, TS09, TS10, TS11, TS12, TS13, TS14, TS15, TS16, TS17, TS18, TS19 ->|
// --               |     |     |              |                       |                                                     |     |
// --               |<----|     |              |                       |---------------------------------------------------->|     |
// --               |           |              |                                                                                   |
// --               |---------->|              |<----------------------------------------------------------------------------------|
// --
// --                                                                                                    --
// --             (6) не следует явно указывать IP-адрес, иначе нет преимуществ пула.                    --
// --                 вместо этого указывается IP-адрес, соответстующий имени хоста.                     --
// --                 пример явного задания IP-адреса (NTP сервер time.nist.gov):                        --
// --                 IPAddress timeServer(129, 6, 15, 28);                                              --
// --                                                                                                    --
// --             (7) KP (keypress) - контроль нажатия встроенной кнопки "FLASH"                         --
// --                 она подключена к земле GPIO0. её можно использовать как обычную кнопку.            --
// --                 если программно подтянуть вывод GPIO0 с помощью внутреннего подтягивающего         --
// --                 резистора к высокому уровню, то появление LOW на этом выводе означает НАЖАТИЕ.     --
// --                                                                                                    --
// --                 при коротком нажатии - в UART выводится строка "short click"                       --
// --                 при долгом нажатии   - в UART выводится строка "long click"                        --
// --                                                                                                    --
// --                 справка о контакте контроллера/платы для кнопки "FLASH"                            --
// --                 15 (IO0, GPIO0, SPICS2) - в режиме INPUT_PULLUP                                    --
// --                                                                                                    --
// --             (8) БИБЛИОТЕКИ, сопряжённые с проектом                                                 --
// --                                                                                                    --
// --                         Arduino.h                                                                  --
// --                         ESP8266WiFi.h                                                              --
// --                         WiFiUdp.h                                                                  --
// --                                                                                                    --
// --             (9) МЕТОДЫ, которые вызываются из сопряжённых с проектом библиотек                     --
// --                                                                                                    --
// --                         Serial.begin          начальная настройка модуля UART                      --
// --                         Serial.println        вывод строки в UART                                  --
// --                         Serial.print          вывод символов в UART                                --
// --                         WiFi.begin            регистрация в сети WIFI                              --
// --                         WiFi.mode             начальная настройка модуля WIFI                      --
// --                         WiFi.status           состояние соединения WiFi                            --
// --                         WiFi.scanNetworks     поиск активных точек подключения WIFI                --
// --                         WiFi.hostByName       выбор IP адреса хоста по имени                       --
// --                         WiFi.disconnect       отключение модуля WIFI                               --
// --                         udp.begin             начало работы с протоколом UDP                       --
// --                         udp.read              чтение кадра UDP                                     --
// --                         udp.write             запись данных в кадр UDP                             --
// --                         udp.beginPacket       начало кадра UDP                                     --
// --                         udp.endPacket         конец кадра UDP                                      --
// --                         udp.parsePacket       синтаксический разбор кадра UDP                      --
// --                                                                                                    --
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --------------------------------------------------------------------------------------------------------
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

#include "esp8266_test.h"

void setup()

{

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                       ОДНОКРАТНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // вывод в UART значения времени                                               timescan
  // включение UART, модуля WiFi. подключение к сети по UDP
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS00
  // включение, настройка UART
  // начало печати отчёта
  // ----------------------------------------------------------------------------

  Serial.begin(9600);          // МЕТОД Serial.begin : скорость 9600 бод
  Serial.println();            // МЕТОД Serial.println
  Serial.println();            // МЕТОД Serial.println
  Serial.print("connect to "); // МЕТОД Serial.print
  Serial.println(ssid);        // МЕТОД Serial.println : значение SSID

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS01
  // включение модуля WIFI. режим station mode.
  // регистрация в сети WIFI
  // ----------------------------------------------------------------------------

  WiFi.mode(WIFI_STA);    // МЕТОД WiFi.mode  : режим station mode
  WiFi.begin(ssid, pass); // МЕТОД WiFi.begin : регистрация в сети WIFI

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS02
  // цикл опроса состояния соединения.
  // ПОКА состояние соединения != WL_CONNECTED: ТО пауза ожидания 500
  // ----------------------------------------------------------------------------

  while (WiFi.status() != WL_CONNECTED) // WiFi.status : состояние соединения

  {

    // ---------------------------------------------------------------------- delay 500
    //                                                                       ЗАДАЧА TS03
    // пауза ожидания 50 мсек
    // ----------------------------------------------------------------------------

    delay(500);

    // -- static uint32_t tmr_ts03;     // программный таймер задачи TS03
    // -- static bool flag_ts03 = true; // программный флаг. разрешение задачи TS03
    // --
    // --     if (flag_ts03 && (millis() - tmr_ts03 >= 500))
    // --
    // --     {
    // --       tmr_ts03 = millis();
    // --       flag_ts03 = false;
    // --     }

    Serial.print("."); // МЕТОД Serial.print
  }

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS04
  // начало сеанса работы по протоколу UDP
  // ----------------------------------------------------------------------------

  udp.begin(localPort); // МЕТОД udp.begin : начало работы с протоколом UDP

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS05
  // печать в UART отчёта.
  // информация о подключении к сети WIFI
  // информация о настройке протокола UDP
  // ----------------------------------------------------------------------------

  Serial.println("");               // МЕТОД Serial.println
  Serial.println("WIFI connected"); // МЕТОД Serial.println
  Serial.print("IP address: ");     // МЕТОД Serial.print
  Serial.println(WiFi.localIP());   // МЕТОД Serial.println, WiFi.localIP
  Serial.print("Local port: ");     // МЕТОД Serial.print
  Serial.println(udp.localPort());  // МЕТОД Serial.println, udp.localPort
  Serial.println("");               // МЕТОД Serial.println

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                       ОДНОКРАТНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // непрерывная световая сигнализация                                              blink
  // начальная настройка контакта встроенного светодиода LED_BUILTIN
  // ----------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////

  pinMode(LED_BUILTIN, OUTPUT); // светодиод. режим OUTPUT

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                       ОДНОКРАТНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // контроль нажатия встроенной кнопки FLASH                                    keypress
  // начальная настройка контакта 15  (IO0, GPIO0, SPICS2)
  // ----------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////

  pinMode(15, INPUT_PULLUP); // кнопка. режим INPUT_PULLUP
}

void loop()

{

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                        РЕГУЛЯРНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // периодический вывод в UART значения времени,                                timescan
  // полученного от сервера времени NTP
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS06
  // подключение к сети WIFI.
  // случайный выбор сервера NTP из пула
  // ----------------------------------------------------------------------------

  WiFi.hostByName(ntpServerName, timeServerIP); // МЕТОД WiFi.hostByName : выбор IP адреса хоста по имени

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS07
  // начальная установка битовых полей пакета запроса времени NTP.
  // установка всех байтов буфера пакета в 0.
  // установка необходимых байтов буфера пакета.
  // байты 4 .. 11 (8 байтов) соответствуют полям Root Delay и Root Dispersion
  // ----------------------------------------------------------------------------

  memset(packetBuffer, 0, NTP_PACKET_SIZE);

  packetBuffer[0] = 0b11100011; // LI, версия, режим
  packetBuffer[1] = 0;          // уровень или тип часов
  packetBuffer[2] = 6;          // интервал
  packetBuffer[3] = 0xEC;       // точность (Peer Clock Precision)

  packetBuffer[12] = 49;
  packetBuffer[13] = 0x4E;
  packetBuffer[14] = 49;
  packetBuffer[15] = 52;

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS08
  // пакет запроса времени NTP сформирован.
  // отправка пакета NTP в выбранный сервер времени.
  // передача пакета в порт 123.
  // ----------------------------------------------------------------------------

  udp.beginPacket(timeServerIP, 123);       // МЕТОД udp.beginPacket : начало кадра UDP
  udp.write(packetBuffer, NTP_PACKET_SIZE); // МЕТОД udp.write : запись данных в кадр UDP
  udp.endPacket();                          // МЕТОД udp.endPacket : конец кадра UDP

  // ---------------------------------------------------------------------- delay 1000
  //                                                                       ЗАДАЧА TS09
  // ожидается ответ сервера на запрос
  // пауза ожидания ответа севера 100 мсек
  // ----------------------------------------------------------------------------

  // delay(1000);

  static bool flag_ts09 = true; // программный флаг. разрешение задачи TS09

  if (flag_ts09 && (millis() - tmr_ts09 >= 1000))

  {
    tmr_ts09 = millis();
    flag_ts09 = false;
  }

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS10
  // попытка разобрать пакет UDP
  // синтаксический разбор результата, полученного из сети WIFI.
  // ЕСЛИ длина пакета = 0 : ТО пакет UDP не принят
  // ЕСЛИ длина пакета != 0 : ТО пакет UDP получен
  // ----------------------------------------------------------------------------

  cb = udp.parsePacket(); // МЕТОД udp.parsePacket : синтаксический разбор кадра UDP

  if (cb)

  {

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS11
    // сохранение полученного пакета в буфер
    // ----------------------------------------------------------------------------

    udp.read(packetBuffer, NTP_PACKET_SIZE); // МЕТОД udp.read : чтение кадра UDP

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS12
    // длина битового поля информации о времени равна четырем байтам (два слова).
    // начинается с 40-го байта принятого пакета.
    // старшее слово - байты 40 .. 41
    // младшее слов0 - байты 42 .. 43
    // ----------------------------------------------------------------------------

    highWord = word(packetBuffer[40], packetBuffer[41]);
    lowWord = word(packetBuffer[42], packetBuffer[43]);

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS13
    // время NTP. количество секунд, прошедших с даты Jan 1 1900
    // объединение четырех байтов в одно длинное целое число
    // время UNIX. количество секунд, прошедших с даты Jan 1 1970
    // вычитание из времени NTP количества секунд в 70 годах
    // время GMT+3. значение времени UNIX в Москве
    // прибавление к времени UNIX количества секунд в tdelta часах
    // ----------------------------------------------------------------------------

    secsSince1900 = highWord << 16 | lowWord;
    epoch = secsSince1900 - seventyYears;
    gmt3 = epoch + tdelta * 3600;

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS14
    // печать в UART информации о результатах расчёта времени
    // время GMT соответствует меридиану Гринвича (Greenwich Meridian time)
    // время GMT+3 соответствует текущему времени в Москве
    // ----------------------------------------------------------------------------

    // Serial.print("packet length = "); // МЕТОД Serial.print
    // Serial.println(cb);               // МЕТОД Serial.println
    // Serial.print("NTP time   = ");    // МЕТОД Serial.print
    // Serial.println(secsSince1900);    // МЕТОД Serial.println
    Serial.print("GMT time   = ");    // МЕТОД Serial.print
    Serial.println(epoch);            // МЕТОД Serial.println
    Serial.print("GMT+3 time = ");    // МЕТОД Serial.print
    Serial.println(gmt3);             // МЕТОД Serial.println

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS15
    // расчёт числа часов, минут, секунд времени GMT+3.
    // применяется формат HH:MM:SS
    // ----------------------------------------------------------------------------

    thrs = int((gmt3 % secsDay) / 3600);
    tmin = int((gmt3 % 3600) / 60);
    tsec = int(gmt3 % 60);

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS16
    // печать в UART информации о количестве часов для времени GMT+3.
    // ЕСЛИ число часов < 10: ТО сначала необходимо напечатать '0'
    // ----------------------------------------------------------------------------

    Serial.print("Moscow time is "); // МЕТОД Serial.print

    if (thrs < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.print(thrs); // МЕТОД Serial.print
    Serial.print(':');  // МЕТОД Serial.print

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS17
    // печать в UART информации о количестве минут для времени GMT+3.
    // ЕСЛИ число минут < 10: ТО сначала необходимо напечатать '0'
    // ----------------------------------------------------------------------------

    if (tmin < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.print(tmin); // МЕТОД Serial.print
    Serial.print(':');  // МЕТОД Serial.print

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS18
    // печать в UART информации о количестве секунд для времени GMT+3.
    // ЕСЛИ число секунд < 10: ТО сначала необходимо напечатать '0'
    // ----------------------------------------------------------------------------

    if (tsec < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.println(tsec); // МЕТОД Serial.println
    Serial.println();     // МЕТОД Serial.println
  }

  // ---------------------------------------------------------------------- delay 3000
  //                                                                       ЗАДАЧА TS19
  // пауза ожидания 3 сек перед новым запросом времени
  // ----------------------------------------------------------------------------

  // delay(3000);

  static bool flag_ts19 = true; // программный флаг. разрешение задачи TS19

  if (flag_ts19 && (millis() - tmr_ts19 >= 1000))

  {
    tmr_ts19 = millis();
    flag_ts19 = false;
  }

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                        РЕГУЛЯРНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // непрерывная световая сигнализация                                              blink
  // управление встроенным светодиодом LED_BUILTIN
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------

  static bool mode_led = false; // светодиод. переключение серий (0 - 30/600, 1 - 500/500)
  static bool flag_led = false; // светодиод. только в серии 0. переключение интервалов
  static int count_led = 0;     // светодиод. счётчик повторений в серии

  if ((!mode_led && (count_led >= serial1_led)) || (mode_led && (count_led >= serial2_led)))

  // ----------------------------------------------------------------------------
  // обновление настроек
  // при достижении счётчиком серии предельного значения
  // ----------------------------------------------------------------------------

  {
    mode_led = !mode_led;
    flag_led = false;
    count_led = 0;
  }
  else

      if (mode_led)

  // ----------------------------------------------------------------------------
  // серия 2
  // переключение состояния светодиода при mode_led = 1 (500/500)
  // ----------------------------------------------------------------------------

  {
    if (millis() - tmr_led >= 500)
    {
      digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
      tmr_led = millis();
      count_led++;
    }
  }

  else

  // ----------------------------------------------------------------------------
  // серия 1
  // переключение состояния светодиода при mode_led = 0 (30/600)
  // ----------------------------------------------------------------------------

  {
    if ((millis() - tmr_led) >= (flag_led ? 20 : 300))
    {
      digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
      tmr_led = millis();
      flag_led = !flag_led;
      count_led++;
    }
  }

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                        РЕГУЛЯРНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // контроль нажатия встроенной кнопки                                          keypress
  // опрос, обработка состояния встроенной кнопки FLASH (IO0, GPIO0, SPICS2) - 15
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////

  static bool flag_key = false;             // кнопка. активация
  static bool state_key = !digitalRead(15); // кнопка. состояние

  // ----------------------------------------------------------------------------
  // нажатие кнопки
  // интервал 100 мс для защиты от дребезга
  // ----------------------------------------------------------------------------

  if (state_key && !flag_key && millis() - tmr_key > 100)

  {
    flag_key = true;
    tmr_key = millis();
    Serial.println("short click");
  }

  // ----------------------------------------------------------------------------
  // нажатие кнопки
  // интервал 500 мс для контроля удержания
  // ----------------------------------------------------------------------------

  if (state_key && flag_key && millis() - tmr_key > 500)

    Serial.println("long click");

  // ----------------------------------------------------------------------------
  // отпускание кнопки
  // интервал 100 мс для защиты от дребезга
  // ----------------------------------------------------------------------------

  if (!state_key && flag_key && millis() - tmr_key > 100)

  {
    flag_key = false;
    tmr_key = millis();
  }
}
