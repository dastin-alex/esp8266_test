// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// ------------------------------------------------------------------------------------------------- module
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --                                                                                                    --
// --                                                                                                    --
// --             "main"                                                                                 --
// --                                                                                                    --
// --                                                                                                    --
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// ---------------------------------------------------------------------------------------------- component
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --                                                                                                    --
// --                                                                                                    --
// -- title       : esp8266_test                                                                         --
// -- version     : 2.0                                                                                  --
// -- framework   : arduino                                                                              --
// -- author      : goldobin a.                                                                          --
// -- company     : cardboard.ru                                                                         --
// -- data        : 08/09/2022                                                                           --
// --                                                                                                    --
// --                                                                                                    --
// -- description :                                                                                      --
// --                                                                                                    --
// --                                                                                                    --
// --             (1) осуществляется ОДНОВРЕМЕННОЕ выполнение трёх потоков задач                         --
// --                 каждому потоку задач соответствует отдельный ПРОЦЕСС                               --
// --                                                                                                    --
// --                 BL (blink)    - непрерывная световая сигнализация                                  --
// --                 KP (keypress) - контроль нажатия встроенной кнопки                                 --
// --                 TS (timescan) - периодический вывод в UART значения времени                        --
// --                                                                                                    --
// --             (2) BL (blink) - это ПРОЦЕСС непрерывной световой сигнализации.                        --
// --                 для сигнализации используется единственный встроенный светодиод LED_BUILTIN.       --
// --                 бесконечно исполняемый цикл описывается таблицей                                   --
// --                                                                                                    --
// --                 Задача       Интервал        LED_BUILTIN                                           --
// --                 BL01         20 мс           HIGH                                                  --
// --                 BL02         300 мс          LOW                                                   --
// --                 BL03         20 мс           HIGH                                                  --
// --                 BL04         300 мс          LOW                                                   --
// --                 BL05         500 мс          HIGH                                                  --
// --                 BL06         500 мс          LOW                                                   --
// --                 BL07         500 мс          HIGH                                                  --
// --                 BL08         500 мс          LOW                                                   --
// --                                                                                                    --
// --             (3) задача BL00 исполняются однократно.                                                --
// --                 поток задач BL01 .. BL08 исполняются непрерывно.                                   --
// --                                                                                                    --
// --             (4) TS (timescan) - это ПРОЦЕСС периодического вывода в UART значения времени.         --
// --                 Клиент UDP/NTP. Считывание значения времени на сервере по протоколу NTP.           --
// --                 Обмен осуществляется с помощью сетевых пакетов UDP.                                --
// --                 Подробная справка о серверах времени NTP и необходимом формате сообщений           --
// --                 http://en.wikipedia.org/wiki/Network_Time_Protocol                                 --
// --                                                                                                    --
// --             (5) поток задач TS00 .. TS04 исполняются однократно.                                   --
// --                 поток задач TS05 .. TS12 исполняются непрерывно. через каждые 3 сек                --
// --                 выполняется алгоритм                                                               --
// --                                                                                                    --
// --                                                                                                    --
// -- (TS00, TS01, TS02, TS03, TS04) -> TS05, TS06, TS07, TS08, TS09, TS10, TS11, TS12 ->|               --
// --                                          |                 |                 |     |               --
// --                                          |                 |---------------->|     |               --
// --                                          |                                         |               --
// --                                          |<----------------------------------------|               --
// --                                                                                                    --
// --                                                                                                    --
// --             (6) не следует явно указывать IP-адрес, иначе нет преимуществ пула.                    --
// --                 вместо этого указывается IP-адрес, соответстующий имени хоста.                     --
// --                 пример явного задания IP-адреса (NTP сервер time.nist.gov):                        --
// --                 IPAddress timeServer(129, 6, 15, 28);                                              --
// --                                                                                                    --
// --             (7) KP (keypress) - контроль нажатия встроенной кнопки "FLASH"                         --
// --                 она подключена к земле GPIO0. её можно использовать как обычную кнопку.            --
// --                 если программно подтянуть вывод GPIO0 с помощью внутреннего подтягивающего         --
// --                 резистора к высокому уровню, то появление LOW на этом выводе означает НАЖАТИЕ.     --
// --                                                                                                    --
// --                 при коротком нажатии - в UART выводится строка "short click"                       --
// --                 при долгом нажатии   - в UART выводится строка "long click"                        --
// --                                                                                                    --
// --                 справка о контакте контроллера/платы для кнопки "FLASH"                            --
// --                 15 (IO0, GPIO0, SPICS2) - в режиме INPUT_PULLUP                                    --
// --                                                                                                    --
// --             (8) БИБЛИОТЕКИ, сопряжённые с проектом                                                 --
// --                                                                                                    --
// --                         Arduino.h                                                                  --
// --                         ESP8266WiFi.h                                                              --
// --                         WiFiUdp.h                                                                  --
// --                                                                                                    --
// --             (9) МЕТОДЫ, которые вызываются из сопряжённых с проектом библиотек                     --
// --                                                                                                    --
// --                         Serial.begin          начальная настройка модуля UART                      --
// --                         Serial.println        вывод строки в UART                                  --
// --                         Serial.print          вывод символов в UART                                --
// --                         WiFi.begin            регистрация в сети WIFI                              --
// --                         WiFi.mode             начальная настройка модуля WIFI                      --
// --                         WiFi.status           состояние соединения WiFi                            --
// --                         WiFi.scanNetworks     поиск активных точек подключения WIFI                --
// --                         WiFi.hostByName       выбор IP адреса хоста по имени                       --
// --                         WiFi.disconnect       отключение модуля WIFI                               --
// --                         udp.begin             начало работы с протоколом UDP                       --
// --                         udp.read              чтение кадра UDP                                     --
// --                         udp.write             запись данных в кадр UDP                             --
// --                         udp.beginPacket       начало кадра UDP                                     --
// --                         udp.endPacket         конец кадра UDP                                      --
// --                         udp.parsePacket       синтаксический разбор кадра UDP                      --
// --                                                                                                    --
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --------------------------------------------------------------------------------------------------------
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

#include "esp8266_control.h"
#include "esp8266_test.h"

void setup()

{

  int no_connect = 20; // контроллер NTP. флаг отсутствия соединения WiFi
  int no_wifi = 1;     // контроллер NTP. флаг отключения задачи TS (timescan)

  pinMode(LED_BUILTIN, OUTPUT); // светодиод. режим OUTPUT
  pinMode(15, INPUT_PULLUP);    // кнопка. режим INPUT_PULLUP

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS00
  // включение, настройка UART
  // начало печати отчёта. режим station mode модуля WiFi
  // ----------------------------------------------------------------------------

  Serial.begin(9600); // МЕТОД Serial.begin : скорость 9600 бод
  Serial.println();   // МЕТОД Serial.println

  WiFi.mode(WIFI_STA); // МЕТОД WiFi.mode  : режим station mode

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS01
  // сканирование точек доступа WiFi.
  // флаг no_wifi - количество имеющихся сетей
  // ----------------------------------------------------------------------------

  WiFi.disconnect();             // МЕТОД WiFi.disconnect : отключение модуля WIFI
  no_wifi = WiFi.scanNetworks(); // МЕТОД WiFi.scanNetworks : поиск активных точек подключения WIFI

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS02
  // печать отчёта в UART.
  // перечисляются SSID имеющихся сетей WiFi.
  // ----------------------------------------------------------------------------

  if (!no_wifi)
  {

    Serial.println("no networks found"); // МЕТОД Serial.println
    WiFi.disconnect();                   // МЕТОД WiFi.disconnect : отключение модуля WIFI
  }

  else

    for (
        int i = 0;
        i < no_wifi;
        ++i)

    {

      Serial.print(i + 1);          // МЕТОД Serial.print : номер в списке
      Serial.print(" : ");          // МЕТОД Serial.print
      Serial.println(WiFi.SSID(i)); // МЕТОД Serial.println : значение i-ого WiFi.SSID
    }

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS03
  // цикл опроса состояния соединения.
  // ПОКА состояние соединения != WL_CONNECTED: ТО пауза ожидания 500
  // ---------------------------------------------------------------------- delay 500

  Serial.println();            // МЕТОД Serial.println
  Serial.print("connect to "); // МЕТОД Serial.print
  Serial.println(ssid);        // МЕТОД Serial.println : значение SSID

  WiFi.begin(ssid, pass); // МЕТОД WiFi.begin : регистрация в сети WIFI

  while (no_connect && (WiFi.status() != WL_CONNECTED)) // WiFi.status : состояние соединения

  {

    delay(500);
    --no_connect;
    Serial.print("."); // МЕТОД Serial.print
  }

  Serial.println(); // МЕТОД Serial.println
  Serial.println(); // МЕТОД Serial.println

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS04
  // печать отчёта в UART.
  // информация о подключении к сети WIFI и настройке протокола UDP
  // ----------------------------------------------------------------------------

  udp.begin(localPort); // МЕТОД udp.begin : начало работы с протоколом UDP

  if (!no_connect)
  {

    Serial.println();
    Serial.println("no WiFi connection"); // МЕТОД Serial.println
    WiFi.disconnect();                    // МЕТОД WiFi.disconnect : отключение модуля WIFI
  }

  else

  {

    Serial.println("");               // МЕТОД Serial.println
    Serial.println("WIFI connected"); // МЕТОД Serial.println
    Serial.print("IP address: ");     // МЕТОД Serial.print
    Serial.println(WiFi.localIP());   // МЕТОД Serial.println, WiFi.localIP
    Serial.print("Local port: ");     // МЕТОД Serial.print
    Serial.println(udp.localPort());  // МЕТОД Serial.println, udp.localPort
    Serial.println();                 // МЕТОД Serial.println
  }

  Serial.println(); // МЕТОД Serial.println
}

void loop()

{

  int cb;                             // длина принятого пакета
  byte packetBuffer[NTP_PACKET_SIZE]; // буфер для хранения принятых и исходящих пакетов
  unsigned long highWord;             // буфер хранения байтов 40,41 принятого пакета
  unsigned long lowWord;              // буфер хранения байтов 42,43 принятого пакета
  unsigned long secsSince1900;        // время NTP. количество секунд, прошедших от даты Jan 1 1900
  unsigned long epoch;                // время UNIX. количество секунд, прошедших от даты Jan 1 1970
  unsigned long tdelta = 3;           // время GMT+3. количество часов смещения от GMT
  unsigned long gmt3;                 // время GMT+3. время UNIX + смещение от GMT
  int thrs, tmin, tsec;               // время GMT+3. количество часов, минут, секунд

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS05
  // подключение к сети WIFI.
  // случайный выбор сервера из пула NTP
  // ----------------------------------------------------------------------------

  WiFi.hostByName(ntpServerName, timeServerIP); // МЕТОД WiFi.hostByName : выбор хоста по имени

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS06
  // начальная установка битовых полей пакета запроса времени NTP.
  // установка необходимых байтов буфера пакета.
  // байты 4 .. 11 (8 байтов) установлены в 0.
  // ----------------------------------------------------------------------------

  memset(packetBuffer, 0, NTP_PACKET_SIZE);

  packetBuffer[0] = 0b11100011; // LI, версия, режим
  packetBuffer[1] = 0;          // уровень или тип часов
  packetBuffer[2] = 6;          // интервал
  packetBuffer[3] = 0xEC;       // точность (Peer Clock Precision)

  packetBuffer[12] = 49;
  packetBuffer[13] = 0x4E;
  packetBuffer[14] = 49;
  packetBuffer[15] = 52;

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS07
  // отправка пакета NTP в выбранный сервер времени.
  // используется порт 123.
  // ----------------------------------------------------------------------------

  udp.beginPacket(timeServerIP, 123);       // МЕТОД udp.beginPacket : начало кадра UDP
  udp.write(packetBuffer, NTP_PACKET_SIZE); // МЕТОД udp.write : запись данных в кадр UDP
  udp.endPacket();                          // МЕТОД udp.endPacket : конец кадра UDP

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS08
  // пауза ожидания ответа севера 100 мсек
  // синтаксический разбор пакета, полученного из сети WIFI.
  // ЕСЛИ длина пакета = 0  : ТО пакет UDP не принят
  // ЕСЛИ длина пакета != 0 : ТО пакет UDP получен
  // ---------------------------------------------------------------------- delay 1000

  delay(1000);

  cb = udp.parsePacket(); // МЕТОД udp.parsePacket : синтаксический разбор кадра UDP

  // ----------------------------------------------------------------------------
  //                                                                       ЗАДАЧА TS09
  // сохранение информации о времени из пакета в буфер.
  // длина битового поля информации о времени равна четырем байтам.
  // старшее слово - байты 40 .. 41 пакета
  // младшее слов0 - байты 42 .. 43 пакета
  // ----------------------------------------------------------------------------

  if (cb)

  {

    udp.read(packetBuffer, NTP_PACKET_SIZE); // МЕТОД udp.read : чтение кадра UDP

    highWord = word(packetBuffer[40], packetBuffer[41]);
    lowWord = word(packetBuffer[42], packetBuffer[43]);

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS10
    // расчёт времени. число часов, минут, секунд времени GMT+3.
    // время NTP      - количество секунд, прошедших с даты Jan 1 1900.
    //                  одно четырёхбайтовое слово.
    // время UNIX     - количество секунд, прошедших с даты Jan 1 1970.
    //                  из времени NTP вычиется количество секунд в 70 годах.
    // время GMT+3.   - соответствует времени UNIX в Москве.
    //                  к времени UNIX прибавляется количество секунд в трёх часах
    // ----------------------------------------------------------------------------

    secsSince1900 = highWord << 16 | lowWord;
    epoch = secsSince1900 - seventyYears;
    gmt3 = epoch + tdelta * 3600;

    thrs = int((gmt3 % secsDay) / 3600);
    tmin = int((gmt3 % 3600) / 60);
    tsec = int(gmt3 % 60);

    // ----------------------------------------------------------------------------
    //                                                                       ЗАДАЧА TS11
    // печать в UART отчёта о времени. применяется формат HH:MM:SS
    // время GMT          - соответствует меридиану Гринвича (Greenwich Meridian time).
    // время GMT+3        - соответствует текущему времени в Москве.
    // пауза ожидания 3 сек перед новым запросом времени.
    // ---------------------------------------------------------------------- delay 3000

    Serial.print("NTP time   = ");   // МЕТОД Serial.print
    Serial.println(secsSince1900);   // МЕТОД Serial.println
    Serial.print("GMT time   = ");   // МЕТОД Serial.print
    Serial.println(epoch);           // МЕТОД Serial.println
    Serial.print("GMT+3 time = ");   // МЕТОД Serial.print
    Serial.println(gmt3);            // МЕТОД Serial.println
    Serial.print("Moscow time is "); // МЕТОД Serial.print

    if (thrs < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.print(thrs); // МЕТОД Serial.print
    Serial.print(':');  // МЕТОД Serial.print

    if (tmin < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.print(tmin); // МЕТОД Serial.print
    Serial.print(':');  // МЕТОД Serial.print

    if (tsec < 10)

      Serial.print('0'); // МЕТОД Serial.print

    Serial.println(tsec); // МЕТОД Serial.println
    Serial.println();     // МЕТОД Serial.println
  }

  delay(3000);

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                        РЕГУЛЯРНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // непрерывная световая сигнализация                                              blink
  // управление встроенным светодиодом LED_BUILTIN
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------

  // static bool mode_led = false; // светодиод. переключение серий (0 - 30/600, 1 - 500/500)
  // static bool flag_led = false; // светодиод. только в серии 0. переключение интервалов
  // static int count_led = 0;     // светодиод. счётчик повторений в серии

  // if ((!mode_led && (count_led >= serial1_led)) || (mode_led && (count_led >= serial2_led)))

  // ----------------------------------------------------------------------------
  // обновление настроек
  // при достижении счётчиком серии предельного значения
  // ----------------------------------------------------------------------------

  // {
  //   mode_led = !mode_led;
  //   flag_led = false;
  //   count_led = 0;
  // }
  // else

  //     if (mode_led)

  // ----------------------------------------------------------------------------
  // серия 2
  // переключение состояния светодиода при mode_led = 1 (500/500)
  // ----------------------------------------------------------------------------

  // {
  //   if (millis() - tmr_led >= 500)
  //   {
  //     digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  //     tmr_led = millis();
  //     count_led++;
  //   }
  // }

  // else

  // ----------------------------------------------------------------------------
  // серия 1
  // переключение состояния светодиода при mode_led = 0 (30/600)
  // ----------------------------------------------------------------------------

  // {
  //   if ((millis() - tmr_led) >= (flag_led ? 20 : 300))
  //   {
  //     digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
  //     tmr_led = millis();
  //     flag_led = !flag_led;
  //     count_led++;
  //   }
  // }

  ///////////////////////////////////////////////////////////////////////////////////////
  // ------------------------------------------------------------------------------------
  //                                                        РЕГУЛЯРНО ИСПОЛНЯЕМЫЙ ПРОЦЕСС
  // контроль нажатия встроенной кнопки                                          keypress
  // опрос, обработка состояния встроенной кнопки FLASH (IO0, GPIO0, SPICS2) - 15
  // ------------------------------------------------------------------------------------
  ///////////////////////////////////////////////////////////////////////////////////////

  // static uint32_t tmr_key;      // таймер кнопки
  // static bool flag_key = false; // кнопка. активация
  // static bool state_key;        // кнопка. состояние

  // state_key = !digitalRead(15); // кнопка. состояние

  // ----------------------------------------------------------------------------
  // нажатие кнопки
  // интервал 100 мс для защиты от дребезга
  // ----------------------------------------------------------------------------

  // if (state_key && !flag_key && millis() - tmr_key > 100)

  // {
  //  flag_key = true;
  //  tmr_key = millis();
  //  Serial.println("short click");
  // }

  // ----------------------------------------------------------------------------
  // нажатие кнопки
  // интервал 500 мс для контроля удержания
  // ----------------------------------------------------------------------------

  // if (state_key && flag_key && millis() - tmr_key > 500)

  //  Serial.println("long click");

  // ----------------------------------------------------------------------------
  // отпускание кнопки
  // интервал 100 мс для защиты от дребезга
  // ----------------------------------------------------------------------------

  // if (!state_key && flag_key && millis() - tmr_key > 100)

  // {
  //  flag_key = false;
  //  tmr_key = millis();
  // }
}
